#+title: Transducers: Ergonomic, efficient data processing

#+begin_quote
I think Transducers are a fundamental primitive that decouples critical logic
from list/sequence processing, and if I had to do Clojure all over I would put
them at the bottom.

- Rich Hickey
#+end_quote

Transducers are an ergonomic and extremely memory-efficient way to process a
data source. Here "data source" means simple collections like Lists or Vectors,
but also potentially large files or generators of infinite data.

Transducers...

- allow the chaining of operations like =map= and =filter= without allocating memory between each step.
- aren't tied to any specific data type; they need only be implemented once.
- vastly simplify "data transformation code".
- are a joy to use!

Example: /While skipping every second line of a file, sum the lengths of only
evenly-lengthed lines./

#+begin_src lisp
(transduce
  ;; How do we want to process each element?
  (compose (step 2) (map #'length) (filter #'evenp))
  ;; How do we want to combine all the elements together?
  #'+
  ;; What's our original data source?
  #p"giant-file.txt")
#+end_src

* Table of Contents :toc_3_gh:
- [[#history-and-motivation][History and Motivation]]
- [[#installation][Installation]]
- [[#usage][Usage]]
  - [[#importing][Importing]]
  - [[#transducers-and-reducers][Transducers and Reducers]]
  - [[#using-the-fold-reducer][Using the =fold= Reducer]]
- [[#differences-with-other-approaches][Differences with other Approaches]]
  - [[#the-common-lisp-loop-macro][The Common Lisp =loop= Macro]]
  - [[#clojure][Clojure]]
  - [[#srfi-171][SRFI-171]]
    - [[#function-names][Function Names]]
    - [[#function-calls-in-scheme][Function Calls in Scheme]]
    - [[#function-additions-and-removals][Function Additions and Removals]]
  - [[#rusts-iterators][Rust's Iterators]]
  - [[#haskells-laziness][Haskell's Laziness]]
- [[#limitations][Limitations]]

* History and Motivation

Originally invented in Clojure and adapted to Scheme as SRFI-171, Transducers
are an excellent way to think about - and efficiently operate on - collections
or streams of data. Transduction operations are strict and don't involve
"laziness" or "thunking" in any way, yet only process the amount of data you ask
them to.

This library draws inspiration from both the original Clojure and SRFI-171,
while adding many other convenient operations commonly found in other languages.
It is, in general, the most complete implementation of the Transducer pattern.

* Installation

* Usage

** Importing

Since this library reuses some symbol names also found in =:cl=, it is expected
that you import =transducers= as follows in your =defpackage=:

#+begin_src lisp
(:local-nicknames (#:t #:transducers))
#+end_src

You can then make relatively clean calls like:

#+begin_src lisp
(t:transduce (t:map #'1+) #'t:vector '(1 2 3))
;; => #(2 3 4)
#+end_src

** Transducers and Reducers

** Using the =fold= Reducer

* Differences with other Approaches

** The Common Lisp =loop= Macro
** Clojure
** SRFI-171

*** Function Names

As this library is intended to be used in a namespaced way (i.e. without =:use=),
we're able to name the functions whatever we wish. This has allowed SRFI-171
functions like =tmap= to have their =t= dropped, meaning the intended call style is
instead =t:map=.

Certain function names have also been renamed from their SRFI-171 variants to
the names more commonly found in other languages.

*** Function Calls in Scheme

Due to differences in how functions are called in Common Lisp and Scheme, all
transducers and reducers that don't take other arguments (like =enumerate= and
=cons= respectively) must be passed quoted:

#+begin_src lisp
(t:transduce (t:map #'1+) #'t:cons '(1 2 3))
#+end_src

instead of:

#+begin_src scheme
(list-transduce (tmap 1+) rcons '(1 2 3))
#+end_src

*** Function Additions and Removals

A few extra functions have been added here that represent idioms common in other
languages, but that are nonetheless missing from the original SRFI-171
specification.

Likewise, a few have been purposefully left unimplemented. These are:

- tappend-map (just compose =map= and =concatenate= yourself)
- tremove (just use =filter=)
- treplace
- reverse-rcons (just use =fold=)

** Rust's Iterators
** Haskell's Laziness

* Limitations

1. This library is general portable, but assumes your CL implementation supports
   tail-recursion.
